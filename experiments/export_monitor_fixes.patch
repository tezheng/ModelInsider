--- a/modelexport/strategies/htp/export_monitor.py
+++ b/modelexport/strategies/htp/export_monitor.py
@@ -65,8 +65,8 @@ class HTPExportStep(Enum):
     ONNX_EXPORT = "onnx_export"
     TAGGER_CREATION = "tagger_creation"
     NODE_TAGGING = "node_tagging"
-    SAVE = "model_save"
-    COMPLETE = "export_complete"
+    TAG_INJECTION = "tag_injection"  # This is step 7, the final step
+    # Note: METADATA_GEN and COMPLETE are not numbered steps
 
 
 @dataclass
@@ -197,6 +197,28 @@ class TextStyler:
         """Format boolean with color."""
         return TextStyler.green_true() if value else TextStyler.red_false()
     
+    @staticmethod
+    def bold_cyan_decimal(number: float, suffix: str = "") -> str:
+        """Format number with only integer part and decimal point colored, rest plain."""
+        # Format based on suffix type
+        if suffix == "M":
+            num_str = f"{number:.1f}"
+        elif suffix == "%":
+            # For percentages, use minimal decimal places
+            if number == int(number):
+                num_str = f"{int(number)}"
+            else:
+                # Remove trailing zeros
+                num_str = f"{number:.1f}".rstrip('0').rstrip('.')
+        else:
+            num_str = f"{number:.2f}"
+        
+        if '.' in num_str:
+            parts = num_str.split('.')
+            return f"\033[1;36m{parts[0]}.\033[0m{parts[1]}{suffix}"
+        else:
+            return f"\033[1;36m{num_str}\033[0m{suffix}"
+    
     @staticmethod
     def format_boolean(value: bool) -> str:
         """Format boolean with color (alias for compatibility)."""
@@ -295,7 +317,7 @@ class HTPConsoleWriter(StepAwareWriter):
         )
         self.verbose = verbose
         self.capture_buffer = capture_buffer  # For capturing output
-        self._total_steps = 8
+        self._total_steps = 7  # Only 7 numbered steps
     
     def _print(self, text: str, **kwargs):
         """Print to console and capture buffer."""
@@ -316,8 +338,7 @@ class HTPConsoleWriter(StepAwareWriter):
             HTPExportStep.ONNX_EXPORT: "📦",
             HTPExportStep.TAGGER_CREATION: "🏷️",
             HTPExportStep.NODE_TAGGING: "🔗",
-            HTPExportStep.SAVE: "🏷️",
-            HTPExportStep.COMPLETE: "📄"
+            HTPExportStep.TAG_INJECTION: "🏷️"
         }
         return icon_map.get(step, "📋")
     
@@ -360,11 +381,11 @@ class HTPConsoleWriter(StepAwareWriter):
         self._print_header(TextStyler.format_step_header(1, self._total_steps, "MODEL PREPARATION", icon))
         
         # Model info with styled numbers - format like baseline (4.4M not 4.38592M)
-        params_str = f"{data.total_parameters/1e6:.1f}"
-        model_line = (f"✅ Model loaded: {data.model_class} "
-                     f"{TextStyler.bold_parens(f'{TextStyler.bold_cyan(data.total_modules)} modules, '
-                     f'{TextStyler.bold_cyan(params_str)}M parameters')}")
-        self._print(model_line)
+        params_num = data.total_parameters/1e6
+        modules_text = f"{TextStyler.bold_cyan(data.total_modules)} modules, "
+        params_text = f"{TextStyler.bold_cyan_decimal(params_num, 'M')} parameters"
+        model_line = f"✅ Model loaded: {data.model_class} {TextStyler.bold_parens(modules_text + params_text)}"
+        self._print(model_line)
         
         # Use output path from console writer if available
         export_target = getattr(self, '_output_path', data.output_path)
@@ -708,49 +729,7 @@ class HTPConsoleWriter(StepAwareWriter):
                 new_prefix = ""
             
             # Find children - handle compound components like layer.0
-            children = []
-            if path == "":
-                # Root level - find all paths with no dots
-                children = [p for p in hierarchy if p and "." not in p]
-            else:
-                # Find immediate children of this path
-                prefix = path + "."
-                potential_children = set()
-                
-                for p in hierarchy:
-                    if p.startswith(prefix) and p != path:
-                        remainder = p[len(prefix):]
-                        
-                        if remainder:
-                            # For compound components like layer.0, find the immediate child
-                            if "." in remainder:
-                                # Try to find the immediate child by checking what paths exist
-                                parts = remainder.split(".")
-                                for i in range(1, len(parts) + 1):
-                                    potential_child = prefix + ".".join(parts[:i])
-                                    if potential_child in hierarchy and potential_child not in potential_children:
-                                        # Check if this is immediate (no intermediate paths)
-                                        is_immediate = True
-                                        for other in hierarchy:
-                                            if (other.startswith(prefix) and 
-                                                other != path and 
-                                                other != potential_child and
-                                                potential_child.startswith(other + ".")):
-                                                is_immediate = False
-                                                break
-                                        if is_immediate:
-                                            potential_children.add(potential_child)
-                                            break
-                            else:
-                                # Simple child
-                                child_path = prefix + remainder
-                                if child_path in hierarchy:
-                                    potential_children.add(child_path)
-                
-                children = sorted(list(potential_children))
-            
-            # Special sort to handle numeric indices and maintain order like baseline
-            def sort_key(p):
-                parts = p.split(".")
+            children = _find_immediate_children(path, hierarchy)
             
             # For modules with operations, print operations first (if any)
             # Skip operations for root module as per baseline
@@ -800,7 +779,7 @@ class HTPConsoleWriter(StepAwareWriter):
                         else:
                             # Single op - check if it needs full path
                             node_name = op_nodes[0]
-                            if any(x in node_name for x in ["LayerNorm", "Gather", "Gemm", "Tanh", "Div", "Shape", "Slice", "Softmax", "MatMul", "Add"]):
+                            if any(x in node_name for x in ["LayerNorm", "Gather", "Gemm", "Tanh", "Div", "Shape", "Slice", "Softmax", "MatMul", "Add", "Relu"]):
                                 if "/" in node_name:
                                     path_parts = node_name.split("/")
                                     styled = TextStyler.magenta_path("/".join(path_parts[:-1]) + "/") + TextStyler.bright_magenta(path_parts[-1])
@@ -837,18 +816,18 @@ class HTPConsoleWriter(StepAwareWriter):
                                                 f'{TextStyler.bold_cyan(total_lines)} lines')}")
     
-    @step(HTPExportStep.SAVE)
-    def write_save(self, export_step: HTPExportStep, data: HTPExportData) -> int:
-        """Step 7: Save ONNX model."""
+    @step(HTPExportStep.TAG_INJECTION)
+    def write_tag_injection(self, export_step: HTPExportStep, data: HTPExportData) -> int:
+        """Step 7: Tag injection."""
         if not self.verbose:
             return 0
         
-        icon = self._get_step_icon(HTPExportStep.SAVE)
+        icon = self._get_step_icon(HTPExportStep.TAG_INJECTION)
         self._print_header(TextStyler.format_step_header(7, self._total_steps, "TAG INJECTION", icon))
         
         self._print(f"🏷️ Hierarchy tag attributes: {'enabled' if data.embed_hierarchy_attributes else 'disabled'}")
         self._print("✅ Tags injected into ONNX model successfully")
         # Use output path from console writer if available
         onnx_file = getattr(self, '_output_path', data.output_path)
         self._print(f"📄 Updated ONNX file: {onnx_file}")
         
@@ -853,32 +832,43 @@ class HTPConsoleWriter(StepAwareWriter):
         
         return 1
     
-    @step(HTPExportStep.COMPLETE)
-    def write_complete(self, export_step: HTPExportStep, data: HTPExportData) -> int:
-        """Step 8: Export complete with summary."""
+    def write_metadata_and_summary(self, data: HTPExportData) -> int:
+        """Write metadata generation message and final summary (not numbered steps)."""
         if not self.verbose:
             return 0
         
-        icon = self._get_step_icon(HTPExportStep.COMPLETE)
-        self._print_header(TextStyler.format_step_header(8, self._total_steps, "METADATA GENERATION", icon))
+        # Metadata generation section (no step number)
+        self._print("")
+        self._print_separator()
+        self._print("📄 METADATA GENERATION")
+        self._print_separator()
         
         self._print("✅ Metadata file created successfully")
         if data.output_path:
             metadata_path = str(Path(data.output_path).with_suffix('')) + "_htp_metadata.json"
             self._print(f"📄 Metadata file: {metadata_path}")
         
         # Add the final export summary as a separate section
         self._print("")
         self._print_header("📋 FINAL EXPORT SUMMARY")
         
         # Format time properly (e.g., 4.83s not 61.09s)
-        time_str = f"{data.export_time:.2f}" if data.export_time < 10 else f"{data.export_time:.0f}"
-        self._print(f"🎉 HTP Export completed successfully in {TextStyler.bold_cyan(time_str)}s!")
+        self._print(f"🎉 HTP Export completed successfully in {TextStyler.bold_cyan_decimal(data.export_time, 's')}!")
         
         self._print("📊 Export Statistics:")
-        # Format time properly
-        time_str = f"{data.export_time:.2f}" if data.export_time < 10 else f"{data.export_time:.0f}"
-        self._print(f"   • Export time: {TextStyler.bold_cyan(time_str)}s")
+        self._print(f"   • Export time: {TextStyler.bold_cyan_decimal(data.export_time, 's')}")
         self._print(f"   • Hierarchy modules: {TextStyler.bold_cyan(len(data.hierarchy))}")
         self._print(f"   • ONNX nodes: {TextStyler.bold_cyan(data.total_nodes)}")
         self._print(f"   • Tagged nodes: {TextStyler.bold_cyan(len(data.tagged_nodes))}")
@@ -1074,16 +1064,16 @@ class HTPMetadataWriter(StepAwareWriter):
         
         return 1
     
-    @step(HTPExportStep.SAVE)
-    def write_save(self, export_step: HTPExportStep, data: HTPExportData) -> int:
-        """Record model save details."""
-        self.metadata["report"]["steps"]["model_save"] = {
+    @step(HTPExportStep.TAG_INJECTION)
+    def write_tag_injection(self, export_step: HTPExportStep, data: HTPExportData) -> int:
+        """Record tag injection details."""
+        self.metadata["report"]["steps"]["tag_injection"] = {
             "output_path": data.output_path,
             "hierarchy_attributes_embedded": data.embed_hierarchy_attributes,
-            "file_saved": True,
+            "tags_injected": True,
             "timestamp": data.timestamp
         }
         
         return 1
     
-    @step(HTPExportStep.COMPLETE)
-    def write_complete(self, export_step: HTPExportStep, data: HTPExportData) -> int:
+    def write_export_complete(self, data: HTPExportData) -> None:
         """Record export completion with full statistics."""
         self.metadata["export_context"]["export_time_seconds"] = round(data.export_time, 2)
@@ -1145,13 +1135,132 @@ class HTPMetadataWriter(StepAwareWriter):
 # TEXT REPORT WRITER WITH COMPLETE CONSOLE OUTPUT
 # ============================================================================
 
 class HTPReportWriter(StepAwareWriter):
-    """Full text report writer that captures ALL console output."""
+    """Full text report writer that generates complete report without truncation."""
     
     def __init__(self, output_path: str, console_buffer: io.StringIO = None):
         super().__init__()
         self.output_path = Path(output_path).with_suffix("").as_posix()
         self.report_path = f"{self.output_path}{Config.REPORT_SUFFIX}"
         self.buffer = io.StringIO()
         self.console_buffer = console_buffer
+        self._step_outputs = {}  # Store outputs for each step
+        self._last_data = None  # Store latest data for hierarchy generation
         self._write_header()
     
@@ -1161,14 +1270,151 @@ class HTPReportWriter(StepAwareWriter):
         self.buffer.write("HTP EXPORT FULL REPORT\n")
         self.buffer.write("=" * Config.SEPARATOR_LENGTH + "\n")
         self.buffer.write(f"Generated: {time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())}\n\n")
     
+    def _store_step_output(self, step: HTPExportStep, content: str):
+        """Store step output for later use."""
+        self._step_outputs[step] = content
+    
+    def write(self, export_step: HTPExportStep, data: HTPExportData) -> int:
+        """Override to store data for report generation."""
+        # Store the latest data for hierarchy generation
+        self._last_data = data
+        # Call parent implementation which handles step handlers
+        return super().write(export_step, data)
+    
+    def _generate_full_hierarchy(self, data: HTPExportData) -> str:
+        """Generate complete hierarchy tree without truncation."""
+        if not data.hierarchy or not data.tagged_nodes:
+            return ""
+        
+        lines = []
+        hierarchy = data.hierarchy
+        tagged_nodes = data.tagged_nodes
+        
+        # Same logic as console but WITHOUT truncation
+        def print_module_and_ops(path: str, prefix: str = "", is_last: bool = True):
+            info = hierarchy.get(path, {})
+            class_name = info.get("class_name", "Unknown")
+            tag = info.get("traced_tag", "")
+            
+            # Count nodes for this module
+            if path:
+                module_tag_prefix = tag
+                node_count = len([n for n, t in tagged_nodes.items() if t == tag or t.startswith(tag + "/")])
+            else:
+                node_count = len(tagged_nodes)
+            
+            # Print module line
+            if path:
+                connector = "└── " if is_last else "├── "
+                lines.append(f"{prefix}{connector}{class_name}: {path} ({node_count} nodes)")
+                new_prefix = prefix + ("    " if is_last else "│   ")
+            else:
+                lines.append(f"{class_name} ({node_count} ONNX nodes)")
+                new_prefix = ""
+            
+            # Find and print children
+            children = _find_immediate_children(path, hierarchy)
+            
+            # Special sort to handle numeric indices and maintain order
+            def sort_key(p):
+                parts = p.split(".")
+                result = []
+                for part in parts:
+                    try:
+                        result.append((0, int(part)))
+                    except ValueError:
+                        if part == "self":
+                            result.append((1, "a_self"))
+                        elif part == "output":
+                            result.append((1, "z_output"))
+                        else:
+                            result.append((1, part))
+                return result
+            
+            children.sort(key=sort_key)
+            
+            # Print operations for this module
+            if tag and node_count > 0 and path != "":
+                # Check if this module has direct operations
+                has_direct_ops = True
+                if children:
+                    child_tags = [hierarchy.get(c, {}).get("traced_tag", "") for c in children]
+                    child_node_count = sum(len([n for n, t in tagged_nodes.items() if t == ct]) for ct in child_tags)
+                    if child_node_count >= node_count:
+                        has_direct_ops = False
+                
+                if has_direct_ops:
+                    # Group operations by type
+                    from collections import defaultdict
+                    ops_by_type = defaultdict(list)
+                    for node_name in [n for n, t in tagged_nodes.items() if t == tag]:
+                        if "/" in node_name:
+                            parts = node_name.split("/")
+                            op_type = parts[-1].split("_")[0] if "_" in parts[-1] else parts[-1]
+                        else:
+                            op_type = node_name.split("_")[0] if "_" in node_name else node_name
+                        ops_by_type[op_type].append(node_name)
+                    
+                    # Print each operation type
+                    op_items = sorted(ops_by_type.items())
+                    for i, (op_type, op_nodes) in enumerate(op_items):
+                        is_last_op = (i == len(op_items) - 1) and len(children) == 0
+                        op_connector = "└── " if is_last_op else "├── "
+                        
+                        if len(op_nodes) > 1:
+                            lines.append(f"{new_prefix}{op_connector}{op_type} ({len(op_nodes)} ops)")
+                        else:
+                            # Single op - check if it needs full path
+                            node_name = op_nodes[0]
+                            if any(x in node_name for x in ["LayerNorm", "Gather", "Gemm", "Tanh", "Div", "Shape", "Slice", "Softmax", "MatMul", "Add", "Relu"]):
+                                if "/" in node_name:
+                                    lines.append(f"{new_prefix}{op_connector}{op_type}: {node_name}")
+                                else:
+                                    lines.append(f"{new_prefix}{op_connector}{op_type}")
+                            else:
+                                lines.append(f"{new_prefix}{op_connector}{op_type}")
+            
+            # Print children
+            for i, child in enumerate(children):
+                is_last_child = (i == len(children) - 1)
+                print_module_and_ops(child, new_prefix, is_last_child)
+        
+        print_module_and_ops("")
+        return "\n".join(lines)
+    
+    def _get_nodes_by_tag(self, tagged_nodes: dict) -> dict:
+        """Get nodes grouped by tag."""
+        from collections import defaultdict
+        nodes_by_tag = defaultdict(lambda: defaultdict(list))
+        for node_name, tag in tagged_nodes.items():
+            op_type = node_name.split('_')[0] if '_' in node_name else node_name
+            nodes_by_tag[tag][op_type].append(node_name)
+        return dict(nodes_by_tag)
+    
     def flush(self):
-        """Write the complete console output to report file."""
-        # If we have console buffer, append its content (stripped of ANSI)
+        """Write the complete report with full hierarchy (no truncation)."""
+        # Generate report programmatically instead of copying console output
+        # This ensures we have the full hierarchy without truncation
+        
+        # Start with console output for most sections
         if self.console_buffer:
             console_output = self.console_buffer.getvalue()
             plain_output = TextStyler.strip_ansi(console_output)
-            self.buffer.write(plain_output)
+            
+            # Split output into sections
+            sections = plain_output.split("🌳 Complete HF Hierarchy with ONNX Nodes:")
+            
+            if len(sections) > 1:
+                # Write everything before the hierarchy
+                self.buffer.write(sections[0])
+                
+                # Write the full hierarchy header
+                self.buffer.write("🌳 Complete HF Hierarchy with ONNX Nodes:\n")
+                self.buffer.write("-" * 60 + "\n")
+                
+                # Check if we have stored data for hierarchy generation
+                if hasattr(self, '_last_data') and self._last_data:
+                    # Generate and write the FULL hierarchy (no truncation)
+                    full_hierarchy = self._generate_full_hierarchy(self._last_data)
+                    self.buffer.write(full_hierarchy)
+                    self.buffer.write("\n")
+                else:
+                    # Fallback: use console output but remove truncation messages
+                    remaining = "🌳 Complete HF Hierarchy with ONNX Nodes:".join(sections[1:])
+                    lines = remaining.split('\n')
+                    filtered_lines = []
+                    skip_next = False
+                    for line in lines:
+                        if "truncated for console" in line or (("showing" in line) and ("lines" in line)):
+                        skip_next = True
+                        continue
+                    if skip_next and not line.strip():
+                        skip_next = False
+                        continue
+                    filtered_lines.append(line)
+                
+                self.buffer.write('\n'.join(filtered_lines))
+            else:
+                # No hierarchy section found, write as-is
+                self.buffer.write(plain_output)
         
         # Write to file
         with open(self.report_path, 'w', encoding='utf-8') as f:
             f.write(self.buffer.getvalue())
 
 
+# ============================================================================
+# MODULE-LEVEL FUNCTIONS
+# ============================================================================
+
+def _find_immediate_children(parent_path: str, hierarchy: dict) -> list:
+    """
+    Find immediate children of a module path with improved compound handling.
+    
+    This implementation combines:
+    - Clear universal design that works with any module hierarchy
+    - Sophisticated handling of compound components (e.g., layer.0)
+    - Efficient single-pass algorithm
+    - Smart sorting with numeric awareness
+    """
+    if parent_path == "":
+        # Root case: find top-level modules (no dots in path)
+        return sorted([p for p in hierarchy if p and '.' not in p])
+    
+    # Non-root case: find children under parent path
+    prefix = parent_path + "."
+    immediate_children = set()
+    
+    for path in hierarchy:
+        if not path.startswith(prefix) or path == parent_path:
+            continue
+            
+        # Extract the portion after parent path
+        suffix = path[len(prefix):]
+        
+        if not suffix:
+            continue
+        
+        # Check for immediate vs nested children
+        if '.' not in suffix:
+            # Simple immediate child (e.g., parent.child)
+            immediate_children.add(path)
+        else:
+            # Compound pattern handling (e.g., parent.layer.0)
+            parts = suffix.split('.')
+            
+            # Check if this is a numbered pattern (name.number)
+            if len(parts) == 2 and parts[1].isdigit():
+                # This is a compound immediate child (e.g., encoder.layer.0)
+                immediate_children.add(path)
+            else:
+                # Multi-level descendant - find the immediate child in the path
+                immediate_child = prefix + parts[0]
+                if immediate_child in hierarchy:
+                    immediate_children.add(immediate_child)
+    
+    # Convert to list and apply smart sorting
+    children = list(immediate_children)
+    
+    def smart_sort_key(path: str):
+        """Smart sorting key for numeric indices and attention components."""
+        # Extract just the child part for sorting
+        child_part = path[len(prefix):] if path.startswith(prefix) else path
+        parts = child_part.split('.')
+        
+        result = []
+        for part in parts:
+            if part.isdigit():
+                # Numeric part - sort as integer
+                result.append((0, int(part)))
+            elif part == "self":
+                # Special case: self comes first in attention
+                result.append((1, "a_self"))
+            elif part == "output":
+                # Special case: output comes last in attention
+                result.append((1, "z_output"))
+            else:
+                # Regular string sorting
+                result.append((1, part))
+        
+        return result
+    
+    children.sort(key=smart_sort_key)
+    return children
+
+
 # ============================================================================
 # MAIN EXPORT MONITOR
 # ============================================================================
@@ -1473,6 +1719,26 @@ class HTPExportMonitor:
         # Log the step
         self.log_step(step, data)
     
+    def finalize_export(self, export_time: float, output_path: str, **kwargs):
+        """Finalize export with metadata generation and summary (not numbered steps)."""
+        # Update data with final info
+        data = HTPExportData()
+        
+        # Copy all accumulated data
+        if hasattr(self, '_step_data'):
+            for step_name, step_kwargs in self._step_data.items():
+                for key, value in step_kwargs.items():
+                    if hasattr(data, key):
+                        setattr(data, key, value)
+        
+        # Set final data
+        data.export_time = export_time
+        data.output_path = output_path
+        for key, value in kwargs.items():
+            if hasattr(data, key):
+                setattr(data, key, value)
+        
+        # Write metadata and summary to console
+        self.console_writer.write_metadata_and_summary(data)
+        
+        # Write export completion to metadata
+        self.metadata_writer.write_export_complete(data)
+    
     @property
     def data(self):
         """Get collected export data (backward compatibility).